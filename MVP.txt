FUTURES CALENDAR ARBITRAGE MVP
Time/Throttle
1. Leaky_bucket.py
- Set to 50 upstream API reqs/s

2. Orders_leaky_bucket.py
- Set to 5 total orders in bucket at a given time

3. Timer.py
- Run below threads while market = open

Dictionary
4. scraper.py
- scrape CME Group for CUSIP/cf bin table
- scrape web api for conIds
- populate config.USTs

5. Future_index.py
- scan secdef for symbols.list
- populate config.FUTURES
STOP UNTIL NEXT LAUNCH

Business Logic
6. cf_ctd.py
- query marketData() for all conIds in FUTURES and USTs
- set FUTURES as base index
- split rows in FUTURES at bid/ask for updated config.FUTURES
  o index: str(conId)_bid or str(conId)_ask else str(conId)_last
  o set col 'price' to _bid, _ask else _last per index
- match CTD UST for each FUTURES row 
- merge CTD pairs into HEDGES comprising FUTURE+CTD arrays
- calculate FUT_KPIs with USTs CF selection logic and append to HEDGES

7. KPIs2_Orders.py
- Define Net_basis_logic()
- create HEDGES_Combos of A_ Hedge + B_Hedge pairs w/o AA or BB dupes
- Apply Net_basis_logic to HEDGES_Combos
- Define margin value with Req_acct_details()
- Impute hedge ratios for HEDGES_Combos pairs
- Discern adjust net_basis with pairs ratios for HEDGES_Combos
- Find and sort(volume-weighted adjusted net_basis for HEDGES_Combos)
  o Pin top 3 to locals 
- Invoke fees.py and config.VOLUME for locals and load to config.ORDERS
- invoke risklimits.py for ORDERS
  o will ping API 1 time/day to get 30 day historical
  o append results for RENTD, VaR, PosR, overlay, sensitivity, stress
    * save to SQL after order clears along with price and time
- save first row to pass risklimits.py to config.SELECTED_ORDER 

8. orders.py
- Send SELECTED_ORDER to API endpoint
- Validate results
- Pend up to 5 orders simultaneously, but no more



